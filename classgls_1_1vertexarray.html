<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>GLS: vertexarray Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GLS
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">GL Stuff - A library aimed at reducing the boilerplate OpenGL code you always have to write.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classgls_1_1vertexarray.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classgls_1_1vertexarray-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vertexarray Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class encapsulating an OpenGL vertex array object.  
 <a href="classgls_1_1vertexarray.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vertexarray_8hpp_source.html">vertexarray.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4854c785616be504e5b5a03ea3802ce0"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1vertexarray.html#a4854c785616be504e5b5a03ea3802ce0">name</a> () const </td></tr>
<tr class="memdesc:a4854c785616be504e5b5a03ea3802ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the OpenGL name of this vertex array.  <a href="#a4854c785616be504e5b5a03ea3802ce0">More...</a><br /></td></tr>
<tr class="separator:a4854c785616be504e5b5a03ea3802ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d1656e5add9a86bc733cc3c21ae81e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1vertexarray.html#a51d1656e5add9a86bc733cc3c21ae81e">bind</a> ()</td></tr>
<tr class="memdesc:a51d1656e5add9a86bc733cc3c21ae81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind this vertex array.  <a href="#a51d1656e5add9a86bc733cc3c21ae81e">More...</a><br /></td></tr>
<tr class="separator:a51d1656e5add9a86bc733cc3c21ae81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a22e500ae0fdb429863130854ffcb5"><td class="memTemplParams" colspan="2">template&lt;GLenum BufferType, typename T , typename U &gt; </td></tr>
<tr class="memitem:ad9a22e500ae0fdb429863130854ffcb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgls_1_1vertexarray.html#ad9a22e500ae0fdb429863130854ffcb5">bind_attribute</a> (const <a class="el" href="classgls_1_1program.html">program</a> &amp;the_program, const std::string &amp;attribute_name, const <a class="el" href="classgls_1_1buffer.html">buffer</a>&lt; BufferType &gt; &amp;the_buffer, GLint size, GLenum type, GLboolean normalized, T stride, U offset)</td></tr>
<tr class="memdesc:ad9a22e500ae0fdb429863130854ffcb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a shader attribute to a buffer source.  <a href="#ad9a22e500ae0fdb429863130854ffcb5">More...</a><br /></td></tr>
<tr class="separator:ad9a22e500ae0fdb429863130854ffcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23879bb7354e47d9a6dc6fc4ffa0a8a"><td class="memTemplParams" colspan="2">template&lt;GLenum BufferType, typename T , typename U &gt; </td></tr>
<tr class="memitem:ab23879bb7354e47d9a6dc6fc4ffa0a8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgls_1_1vertexarray.html#ab23879bb7354e47d9a6dc6fc4ffa0a8a">bind_attribute</a> (GLuint attribute_location, const <a class="el" href="classgls_1_1buffer.html">buffer</a>&lt; BufferType &gt; &amp;the_buffer, GLint size, GLenum type, GLboolean normalized, T stride, U offset)</td></tr>
<tr class="memdesc:ab23879bb7354e47d9a6dc6fc4ffa0a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a shader attribute to a buffer source.  <a href="#ab23879bb7354e47d9a6dc6fc4ffa0a8a">More...</a><br /></td></tr>
<tr class="separator:ab23879bb7354e47d9a6dc6fc4ffa0a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbabc131cb9595e934f78c235c7ff4ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1vertexarray.html#abbabc131cb9595e934f78c235c7ff4ff">unbind_attribute</a> (const <a class="el" href="classgls_1_1program.html">program</a> &amp;the_program, const std::string &amp;attribute_name)</td></tr>
<tr class="memdesc:abbabc131cb9595e934f78c235c7ff4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind a shader attribute.  <a href="#abbabc131cb9595e934f78c235c7ff4ff">More...</a><br /></td></tr>
<tr class="separator:abbabc131cb9595e934f78c235c7ff4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8d3e6c7a76ff6c56b126d905bd3843"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1vertexarray.html#a3c8d3e6c7a76ff6c56b126d905bd3843">unbind_attribute</a> (GLuint attribute_location)</td></tr>
<tr class="memdesc:a3c8d3e6c7a76ff6c56b126d905bd3843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind a shader attribute.  <a href="#a3c8d3e6c7a76ff6c56b126d905bd3843">More...</a><br /></td></tr>
<tr class="separator:a3c8d3e6c7a76ff6c56b126d905bd3843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9c0d807bff8e256207912c0ad541e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1vertexarray.html#a2a9c0d807bff8e256207912c0ad541e6">clear_attribute_bindings</a> ()</td></tr>
<tr class="memdesc:a2a9c0d807bff8e256207912c0ad541e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all attribute bindings.  <a href="#a2a9c0d807bff8e256207912c0ad541e6">More...</a><br /></td></tr>
<tr class="separator:a2a9c0d807bff8e256207912c0ad541e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad791606b16a7822d10c17ac03c813986"><td class="memTemplParams" colspan="2">template&lt;GLenum BufferType&gt; </td></tr>
<tr class="memitem:ad791606b16a7822d10c17ac03c813986"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgls_1_1vertexarray.html#ad791606b16a7822d10c17ac03c813986">bind_index_buffer</a> (const <a class="el" href="classgls_1_1buffer.html">buffer</a>&lt; BufferType &gt; &amp;the_buffer)</td></tr>
<tr class="memdesc:ad791606b16a7822d10c17ac03c813986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind an index buffer to this vertex array.  <a href="#ad791606b16a7822d10c17ac03c813986">More...</a><br /></td></tr>
<tr class="separator:ad791606b16a7822d10c17ac03c813986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdadfc59eebbc0c767bdbe45399c010"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1vertexarray.html#a4cdadfc59eebbc0c767bdbe45399c010">unbind_index_buffer</a> ()</td></tr>
<tr class="memdesc:a4cdadfc59eebbc0c767bdbe45399c010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind the index buffer from this vertex array.  <a href="#a4cdadfc59eebbc0c767bdbe45399c010">More...</a><br /></td></tr>
<tr class="separator:a4cdadfc59eebbc0c767bdbe45399c010"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afec97de60a74d4ae7e752924902c4320"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1vertexarray.html#afec97de60a74d4ae7e752924902c4320">unbind</a> ()</td></tr>
<tr class="memdesc:afec97de60a74d4ae7e752924902c4320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind the currently bound vertex array.  <a href="#afec97de60a74d4ae7e752924902c4320">More...</a><br /></td></tr>
<tr class="separator:afec97de60a74d4ae7e752924902c4320"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class encapsulating an OpenGL vertex array object. </p>
<p>A <a class="el" href="classgls_1_1vertexarray.html" title="Class encapsulating an OpenGL vertex array object. ">gls::vertexarray</a> is an object that encapsulates an OpenGL vertex array object.</p>
<p>Like all objects in GLS, the underlying name is generated at object construction and deleted at destruction. This can be retrieved with <a class="el" href="classgls_1_1vertexarray.html#a4854c785616be504e5b5a03ea3802ce0" title="Retrieve the OpenGL name of this vertex array. ">name()</a>.</p>
<p><b>WARNING:</b> Unlike other OpenGL objects, vertex array objects are <em>not</em> shareable between contexts. As such, a <a class="el" href="classgls_1_1vertexarray.html" title="Class encapsulating an OpenGL vertex array object. ">gls::vertexarray</a> object is only valid for use within the context where it was constructed. No checks are made to ensure it is used properly. If strange behaviour occurs, be sure to check the reported OpenGL errors in a debug configuration and assure you are not transferring the <a class="el" href="classgls_1_1vertexarray.html" title="Class encapsulating an OpenGL vertex array object. ">gls::vertexarray</a> between contexts.</p>
<p>Vertex array objects are basically a way to store the layout and sources of attribute data. While multiple programs can use the same vertex array, it makes less sense to use different vertex arrays to reference the same data. Vertex arrays are meant to be set up once and reused many times. They only save the <em>source</em> of vertex attributes and not the data themselves. This means that it is not necessary to update a vertex array if the data within a buffer object is changed. It <em>does</em> mean however, that if a buffer object is recreated, deleted, or has its name changed, you will need to rebind/unbind the attribute(s) sourcing from that buffer object.</p>
<p>In addition to storing the layout and sources of attribute data, vertex arrays also store the element array binding. This means that you can store a reference to an index buffer within the vertex array as well. The same applies here as well however: If the index buffer object is recreated, deleted, or has its name changed, you will need to rebind/unbind it to/from the vertex array.</p>
<p>To use a <a class="el" href="classgls_1_1vertexarray.html" title="Class encapsulating an OpenGL vertex array object. ">gls::vertexarray</a>, simply call <a class="el" href="classgls_1_1vertexarray.html#a51d1656e5add9a86bc733cc3c21ae81e" title="Bind this vertex array. ">bind()</a>. It will bind the <a class="el" href="classgls_1_1vertexarray.html" title="Class encapsulating an OpenGL vertex array object. ">gls::vertexarray</a> as the current one used for rendering and replace any that was previously bound. To clear the binding, call <a class="el" href="classgls_1_1vertexarray.html#afec97de60a74d4ae7e752924902c4320" title="Unbind the currently bound vertex array. ">unbind()</a>. It is an error in newer versions of OpenGL to render without a bound vertex array.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="comment">// Create and link the program from our compiled shaders</span></div>
<div class="line"><span class="keyword">auto</span> program = <a class="code" href="classgls_1_1program.html">gls::program</a>();</div>
<div class="line">program.link( vertex_shader, fragment_shader );</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> position_buffer = <a class="code" href="classgls_1_1buffer.html">gls::buffer&lt;GL_ARRAY_BUFFER, GL_DYNAMIC_DRAW&gt;</a>();</div>
<div class="line"><span class="keyword">auto</span> position_data = std::vector&lt;float&gt;();</div>
<div class="line">position_data = { -.5f, -.5f, -1.f, .5f, -.5f, -1.f, 0.f, .5f, -1.f };</div>
<div class="line">position_buffer.<a class="code" href="classgls_1_1buffer.html#a1f60c61aba66fea19b70e842d1c3aebb">data</a>( position_data.size() * <span class="keyword">sizeof</span>( float ), position_data.data() );</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> vertexarray = <a class="code" href="classgls_1_1vertexarray.html">gls::vertexarray</a>();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Bind a &quot;position&quot; attribute in the vertex shader to our position buffer</span></div>
<div class="line">vertexarray.bind_attribute( program, <span class="stringliteral">&quot;position&quot;</span>, position_buffer, 3, GL_FLOAT, GL_FALSE, 0, 0 );</div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4854c785616be504e5b5a03ea3802ce0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the OpenGL name of this vertex array. </p>
<dl class="section return"><dt>Returns</dt><dd>OpenGL name of this vertex array </dd></dl>

</div>
</div>
<a class="anchor" id="a51d1656e5add9a86bc733cc3c21ae81e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind this vertex array. </p>

</div>
</div>
<a class="anchor" id="afec97de60a74d4ae7e752924902c4320"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void unbind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unbind the currently bound vertex array. </p>

</div>
</div>
<a class="anchor" id="ad9a22e500ae0fdb429863130854ffcb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bind_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgls_1_1program.html">program</a> &amp;&#160;</td>
          <td class="paramname"><em>the_program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgls_1_1buffer.html">buffer</a>&lt; BufferType &gt; &amp;&#160;</td>
          <td class="paramname"><em>the_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>normalized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a shader attribute to a buffer source. </p>
<p>Shader attributes need to have a data source to provide the required attribute data to a vertex shader. This method binds an attribute with the given name in the given program to the given buffer source. Since attributes may be interleaved within the same buffer, providing a non-zero stride and offset might be necessary as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_program</td><td>The program in which the attribute resides </td></tr>
    <tr><td class="paramname">attribute_name</td><td>The name of the attribute to bind </td></tr>
    <tr><td class="paramname">the_buffer</td><td>The buffer to source data from </td></tr>
    <tr><td class="paramname">size</td><td>The size (number of components) of an attribute </td></tr>
    <tr><td class="paramname">type</td><td>The data type of an attribute component </td></tr>
    <tr><td class="paramname">normalized</td><td>Whether to normalize integer data to the floating point range [0.f, 1.f] for unsigned or [-1.f, 1.f] for signed in the shader </td></tr>
    <tr><td class="paramname">stride</td><td>Number of bytes between successive attribute elements in the buffer </td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset into the buffer where the first element is located </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab23879bb7354e47d9a6dc6fc4ffa0a8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bind_attribute </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>attribute_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgls_1_1buffer.html">buffer</a>&lt; BufferType &gt; &amp;&#160;</td>
          <td class="paramname"><em>the_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>normalized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a shader attribute to a buffer source. </p>
<p>Shader attributes need to have a data source to provide the required attribute data to a vertex shader. This method binds an attribute with the given location to the given buffer source. Since attributes may be interleaved within the same buffer, providing a non-zero stride and offset might be necessary as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute_location</td><td>Location of the attribute </td></tr>
    <tr><td class="paramname">the_buffer</td><td>The buffer to source data from </td></tr>
    <tr><td class="paramname">size</td><td>The size (number of components) of an attribute </td></tr>
    <tr><td class="paramname">type</td><td>The data type of an attribute component </td></tr>
    <tr><td class="paramname">normalized</td><td>Whether to normalize integer data to the floating point range [0.f, 1.f] for unsigned or [-1.f, 1.f] for signed in the shader </td></tr>
    <tr><td class="paramname">stride</td><td>Number of bytes between successive attribute elements in the buffer </td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset into the buffer where the first element is located </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbabc131cb9595e934f78c235c7ff4ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unbind_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgls_1_1program.html">program</a> &amp;&#160;</td>
          <td class="paramname"><em>the_program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attribute_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unbind a shader attribute. </p>
<p>This method disables the vertex attribute with the given name in the given program from sourcing its data from a buffer. If the attribute is present in the shader, it will be set to a constant value for every invocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_program</td><td>The program in which the attribute resides </td></tr>
    <tr><td class="paramname">attribute_name</td><td>The name of the attribute to unbind </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c8d3e6c7a76ff6c56b126d905bd3843"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unbind_attribute </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>attribute_location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unbind a shader attribute. </p>
<p>This method disables the vertex attribute with the given location from sourcing its data from a buffer. If the attribute is present in the shader, it will be set to a constant value for every invocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute_location</td><td>The location of the attribute to unbind </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a9c0d807bff8e256207912c0ad541e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear_attribute_bindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all attribute bindings. </p>
<p>Calling this method is equivalent to this code: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> max_vertex_attributes = GLint();</div>
<div class="line">check_gl_error( glGetIntegerv( GL_MAX_VERTEX_ATTRIBS, &amp;max_vertex_attributes ) );</div>
<div class="line">vertexarray.bind();</div>
<div class="line"><span class="keywordflow">for</span>( GLuint index = 0; index &lt; max_vertex_attributes; ++index ) {</div>
<div class="line">    glDisableVertexAttribArray( index );</div>
<div class="line">}</div>
<div class="line">vertexarray.unbind();</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad791606b16a7822d10c17ac03c813986"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bind_index_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgls_1_1buffer.html">buffer</a>&lt; BufferType &gt; &amp;&#160;</td>
          <td class="paramname"><em>the_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind an index buffer to this vertex array. </p>
<p>When doing indexed rendering, it is required that you bind a buffer containing the indices of the vertices to be rendered to the element array buffer binding within this vertex array. That is what this method does.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_buffer</td><td>The index buffer to bind to this vertex array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4cdadfc59eebbc0c767bdbe45399c010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unbind_index_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unbind the index buffer from this vertex array. </p>
<p>This will clear the element array buffer binding within this vertex array. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
