<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>GLS: buffer&lt; Target, Usage &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GLS
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">GL Stuff - A library aimed at reducing the boilerplate OpenGL code you always have to write.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classgls_1_1buffer.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classgls_1_1buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">buffer&lt; Target, Usage &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class encapsulating an OpenGL buffer object.  
 <a href="classgls_1_1buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4854c785616be504e5b5a03ea3802ce0"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1buffer.html#a4854c785616be504e5b5a03ea3802ce0">name</a> () const </td></tr>
<tr class="memdesc:a4854c785616be504e5b5a03ea3802ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the OpenGL name of this buffer.  <a href="#a4854c785616be504e5b5a03ea3802ce0">More...</a><br /></td></tr>
<tr class="separator:a4854c785616be504e5b5a03ea3802ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a14923615a6fd7034d331445d0b7b0"><td class="memItemLeft" align="right" valign="top">GLsizeiptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1buffer.html#af6a14923615a6fd7034d331445d0b7b0">size</a> () const </td></tr>
<tr class="memdesc:af6a14923615a6fd7034d331445d0b7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the size of buffer.  <a href="#af6a14923615a6fd7034d331445d0b7b0">More...</a><br /></td></tr>
<tr class="separator:af6a14923615a6fd7034d331445d0b7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d1656e5add9a86bc733cc3c21ae81e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1buffer.html#a51d1656e5add9a86bc733cc3c21ae81e">bind</a> ()</td></tr>
<tr class="memdesc:a51d1656e5add9a86bc733cc3c21ae81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind this buffer to its target.  <a href="#a51d1656e5add9a86bc733cc3c21ae81e">More...</a><br /></td></tr>
<tr class="separator:a51d1656e5add9a86bc733cc3c21ae81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e82cf0c96ba99ea3d3fc8a5b1c1ea7f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e82cf0c96ba99ea3d3fc8a5b1c1ea7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgls_1_1buffer.html#a9e82cf0c96ba99ea3d3fc8a5b1c1ea7f">bind_range</a> (GLuint index, GLintptr offset, T range_size)</td></tr>
<tr class="memdesc:a9e82cf0c96ba99ea3d3fc8a5b1c1ea7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range to an indexed target.  <a href="#a9e82cf0c96ba99ea3d3fc8a5b1c1ea7f">More...</a><br /></td></tr>
<tr class="separator:a9e82cf0c96ba99ea3d3fc8a5b1c1ea7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f60c61aba66fea19b70e842d1c3aebb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f60c61aba66fea19b70e842d1c3aebb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgls_1_1buffer.html#a1f60c61aba66fea19b70e842d1c3aebb">data</a> (T data_size, const GLvoid *data_ptr)</td></tr>
<tr class="memdesc:a1f60c61aba66fea19b70e842d1c3aebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate storage and upload data.  <a href="#a1f60c61aba66fea19b70e842d1c3aebb">More...</a><br /></td></tr>
<tr class="separator:a1f60c61aba66fea19b70e842d1c3aebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ea0e06aa16cf611451714788c7abb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a25ea0e06aa16cf611451714788c7abb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgls_1_1buffer.html#a25ea0e06aa16cf611451714788c7abb5">sub_data</a> (GLintptr offset, T data_size, const GLvoid *data_ptr)</td></tr>
<tr class="memdesc:a25ea0e06aa16cf611451714788c7abb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload a data range.  <a href="#a25ea0e06aa16cf611451714788c7abb5">More...</a><br /></td></tr>
<tr class="separator:a25ea0e06aa16cf611451714788c7abb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac40f3eca39e836bf84f94972130cb3"><td class="memTemplParams" colspan="2">template&lt;GLenum SourceTarget, GLenum SourceUsage, typename V &gt; </td></tr>
<tr class="memitem:aaac40f3eca39e836bf84f94972130cb3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgls_1_1buffer.html#aaac40f3eca39e836bf84f94972130cb3">copy_sub_data</a> (const <a class="el" href="classgls_1_1buffer.html">buffer</a>&lt; SourceTarget, SourceUsage &gt; &amp;source, GLintptr readoffset, GLintptr writeoffset, V data_size)</td></tr>
<tr class="memdesc:aaac40f3eca39e836bf84f94972130cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a data range from another buffer into this one.  <a href="#aaac40f3eca39e836bf84f94972130cb3">More...</a><br /></td></tr>
<tr class="separator:aaac40f3eca39e836bf84f94972130cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374264fe4aa10363e598df5ad7cfe619"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a374264fe4aa10363e598df5ad7cfe619"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgls_1_1buffer.html#a374264fe4aa10363e598df5ad7cfe619">get_sub_data</a> (GLintptr offset, T data_size, GLvoid *data_ptr)</td></tr>
<tr class="memdesc:a374264fe4aa10363e598df5ad7cfe619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read back data from the buffer.  <a href="#a374264fe4aa10363e598df5ad7cfe619">More...</a><br /></td></tr>
<tr class="separator:a374264fe4aa10363e598df5ad7cfe619"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afec97de60a74d4ae7e752924902c4320"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1buffer.html#afec97de60a74d4ae7e752924902c4320">unbind</a> ()</td></tr>
<tr class="memdesc:afec97de60a74d4ae7e752924902c4320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind the current buffer from the target.  <a href="#afec97de60a74d4ae7e752924902c4320">More...</a><br /></td></tr>
<tr class="separator:afec97de60a74d4ae7e752924902c4320"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;GLenum Target = GL_ARRAY_BUFFER, GLenum Usage = GL_DYNAMIC_DRAW&gt;<br />
class gls::buffer&lt; Target, Usage &gt;</h3>

<p>Class encapsulating an OpenGL buffer object. </p>
<p>A <a class="el" href="classgls_1_1buffer.html" title="Class encapsulating an OpenGL buffer object. ">gls::buffer</a> is an object that encapsulates an OpenGL buffer object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Target</td><td>The target this buffer object will be bound to when calling <a class="el" href="classgls_1_1buffer.html#a51d1656e5add9a86bc733cc3c21ae81e" title="Bind this buffer to its target. ">bind()</a> </td></tr>
    <tr><td class="paramname">Usage</td><td>The usage hint passed to OpenGL when the buffer storage is created</td></tr>
  </table>
  </dd>
</dl>
<p>Like all objects in GLS, the underlying name is generated at object construction and deleted at destruction. This can be retrieved with <a class="el" href="classgls_1_1buffer.html#a4854c785616be504e5b5a03ea3802ce0" title="Retrieve the OpenGL name of this buffer. ">name()</a>.</p>
<p>Buffer objects store arbitrary data within server (GPU) memory. This buffer can then be used to e.g. provide attribute data to shaders or act as the data storage for uniform blocks.</p>
<p>All the provided methods offer different ways of manipulating the buffer's data content. One must be aware of the performance implications some transfers might have. As a general rule of thumb, try to avoid unnecessary transfers between client and server, and re-use data within the buffers if possible.</p>
<p>To use a <a class="el" href="classgls_1_1buffer.html" title="Class encapsulating an OpenGL buffer object. ">gls::buffer</a>, simply call <a class="el" href="classgls_1_1buffer.html#a51d1656e5add9a86bc733cc3c21ae81e" title="Bind this buffer to its target. ">bind()</a>. It will bind the <a class="el" href="classgls_1_1buffer.html" title="Class encapsulating an OpenGL buffer object. ">gls::buffer</a> to its target binding and replace any previously bound to that target. To clear the binding to that target, call <a class="el" href="classgls_1_1buffer.html#afec97de60a74d4ae7e752924902c4320" title="Unbind the current buffer from the target. ">unbind()</a>.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> buffer1 = <a class="code" href="classgls_1_1buffer.html">gls::buffer&lt;GL_ARRAY_BUFFER, GL_DYNAMIC_DRAW&gt;</a>();</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> write_data = std::vector&lt;float&gt;();</div>
<div class="line">write_data = { 1.f, 2.f, 3.f, 4.f, 5.f, 6.f, 7.f, 8.f, 9.f };</div>
<div class="line">buffer1.<a class="code" href="classgls_1_1buffer.html#a1f60c61aba66fea19b70e842d1c3aebb">data</a>( write_data.size() * <span class="keyword">sizeof</span>( float ), write_data.data() );</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> buffer2 = <a class="code" href="classgls_1_1buffer.html">gls::buffer&lt;GL_UNIFORM_BUFFER, GL_STREAM_DRAW&gt;</a>();</div>
<div class="line">buffer2.<a class="code" href="classgls_1_1buffer.html#aaac40f3eca39e836bf84f94972130cb3">copy_sub_data</a>( buffer1, 0, 0, buffer1.size() );</div>
<div class="line"></div>
<div class="line">write_data = { 0.f, 0.f, 0.f };</div>
<div class="line">buffer2.sub_data( 3 * <span class="keyword">sizeof</span>( <span class="keywordtype">float</span> ), write_data.size() * <span class="keyword">sizeof</span>( float ), write_data.data() );</div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4854c785616be504e5b5a03ea3802ce0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the OpenGL name of this buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>OpenGL name of this buffer </dd></dl>

</div>
</div>
<a class="anchor" id="af6a14923615a6fd7034d331445d0b7b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLsizeiptr size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the size of buffer. </p>
<p>After calling <a class="el" href="classgls_1_1buffer.html#a1f60c61aba66fea19b70e842d1c3aebb" title="Allocate storage and upload data. ">data()</a>, storage is allocated for the buffer by the GL. This method returns how much storage was requested during the last allocation that took place.</p>
<dl class="section return"><dt>Returns</dt><dd>OpenGL name of this buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a51d1656e5add9a86bc733cc3c21ae81e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind this buffer to its target. </p>
<p>Bind this buffer to the target specified by the Target template parameter. This replaces any previous binding on that target. </p>

</div>
</div>
<a class="anchor" id="afec97de60a74d4ae7e752924902c4320"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void unbind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unbind the current buffer from the target. </p>
<p>Unbind the buffer currently bound to the target specified by the Target template parameter. </p>

</div>
</div>
<a class="anchor" id="a9e82cf0c96ba99ea3d3fc8a5b1c1ea7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bind_range </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLintptr&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>range_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range to an indexed target. </p>
<p>Bind a range given by an offset into this buffer along with the size of the range in bytes to an indexed buffer target. The target is specified by the Target template parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the binding point within the target </td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset into the buffer where the range starts </td></tr>
    <tr><td class="paramname">range_size</td><td>Size of the range in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f60c61aba66fea19b70e842d1c3aebb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void data </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLvoid *&#160;</td>
          <td class="paramname"><em>data_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate storage and upload data. </p>
<p>Request the GL to allocate storage for this buffer specifying usage according to the Usage template parameter and optionally upload data to it. If no data should currently be uploaded, pass a nullptr as the second argument.</p>
<p>Even if the new size is equal to the previously allocated size, this method will orphan the buffer. If this is not wanted, use <a class="el" href="classgls_1_1buffer.html#a25ea0e06aa16cf611451714788c7abb5" title="Upload a data range. ">sub_data()</a> instead.</p>
<p>If you only want to partially fill the buffer with data, pass nullptr as the second argument and call <a class="el" href="classgls_1_1buffer.html#a25ea0e06aa16cf611451714788c7abb5" title="Upload a data range. ">sub_data()</a> after this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_size</td><td>Size in bytes of the storage to be allocated </td></tr>
    <tr><td class="paramname">data_ptr</td><td>Pointer to a data source to upload from, or nullptr if no upload should take place </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25ea0e06aa16cf611451714788c7abb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sub_data </td>
          <td>(</td>
          <td class="paramtype">GLintptr&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLvoid *&#160;</td>
          <td class="paramname"><em>data_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upload a data range. </p>
<p>Upload a range of data to the buffer at the given byte offset. If the current buffer is not large enough to hold all the data, a new buffer will be created and will replace the current one. Be aware that if this reallocation takes place, the name of the underlying buffer object will be changed, and updating all references to this buffer may be necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Byte offset into the buffer where the data should be uploaded </td></tr>
    <tr><td class="paramname">data_size</td><td>Size of the range of data to be uploaded in bytes </td></tr>
    <tr><td class="paramname">data_ptr</td><td>Pointer to a data source to upload from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaac40f3eca39e836bf84f94972130cb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copy_sub_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgls_1_1buffer.html">buffer</a>&lt; SourceTarget, SourceUsage &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLintptr&#160;</td>
          <td class="paramname"><em>readoffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLintptr&#160;</td>
          <td class="paramname"><em>writeoffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a data range from another buffer into this one. </p>
<p>This copies a range of data of the specified size in bytes from the read offset in bytes from the source buffer to this buffer at the write offset in bytes. If the current buffer is not large enough to hold all the data, a new buffer will be created and will replace the current one. Be aware that if this reallocation takes place, the name of the underlying buffer object will be changed, and updating all references to this buffer may be necessary.</p>
<p>Because this data transfer takes place on the server (GPU), this avoids any expensive read backs that would be incurred if done manually using a combination of the other methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source buffer to copy data from </td></tr>
    <tr><td class="paramname">readoffset</td><td>Offset in bytes of the start of the range to read from the source buffer </td></tr>
    <tr><td class="paramname">writeoffset</td><td>Offset in bytes to start writing the range to in this buffer </td></tr>
    <tr><td class="paramname">data_size</td><td>Size in bytes of the range to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a374264fe4aa10363e598df5ad7cfe619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_sub_data </td>
          <td>(</td>
          <td class="paramtype">GLintptr&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLvoid *&#160;</td>
          <td class="paramname"><em>data_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read back data from the buffer. </p>
<p>This reads a range of data from the buffer back into client memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset in bytes into the buffer to read the range from </td></tr>
    <tr><td class="paramname">data_size</td><td>Size in bytes of the range </td></tr>
    <tr><td class="paramname">data_ptr</td><td>Pointer to client memory that is large enough to hold the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
