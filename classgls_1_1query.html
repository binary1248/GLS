<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>GLS: query&lt; Target &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GLS
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">GL Stuff - A library aimed at reducing the boilerplate OpenGL code you always have to write.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classgls_1_1query.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgls_1_1query-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">query&lt; Target &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class encapsulating an OpenGL query object.  
 <a href="classgls_1_1query.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="query_8hpp_source.html">query.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4854c785616be504e5b5a03ea3802ce0"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1query.html#a4854c785616be504e5b5a03ea3802ce0">name</a> () const </td></tr>
<tr class="memdesc:a4854c785616be504e5b5a03ea3802ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the OpenGL name of this query.  <a href="#a4854c785616be504e5b5a03ea3802ce0">More...</a><br /></td></tr>
<tr class="separator:a4854c785616be504e5b5a03ea3802ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135fe90ca531f4a7b04d00642b9f0ef6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a135fe90ca531f4a7b04d00642b9f0ef6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgls_1_1query.html#a135fe90ca531f4a7b04d00642b9f0ef6">run</a> (T callable)</td></tr>
<tr class="memdesc:a135fe90ca531f4a7b04d00642b9f0ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the query on the provided callable.  <a href="#a135fe90ca531f4a7b04d00642b9f0ef6">More...</a><br /></td></tr>
<tr class="separator:a135fe90ca531f4a7b04d00642b9f0ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bdf5cca484fb2ba637c39384b27fb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1query.html#ab0bdf5cca484fb2ba637c39384b27fb2">begin</a> ()</td></tr>
<tr class="memdesc:ab0bdf5cca484fb2ba637c39384b27fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the begin of the query block.  <a href="#ab0bdf5cca484fb2ba637c39384b27fb2">More...</a><br /></td></tr>
<tr class="separator:ab0bdf5cca484fb2ba637c39384b27fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf81d3fdaf258088d7692fa70cece087"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1query.html#aaf81d3fdaf258088d7692fa70cece087">end</a> ()</td></tr>
<tr class="memdesc:aaf81d3fdaf258088d7692fa70cece087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the end of the query block.  <a href="#aaf81d3fdaf258088d7692fa70cece087">More...</a><br /></td></tr>
<tr class="separator:aaf81d3fdaf258088d7692fa70cece087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361988764d293148e43ed30d4e44d617"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1query.html#a361988764d293148e43ed30d4e44d617">poll_result</a> (GLint &amp;result)</td></tr>
<tr class="memdesc:a361988764d293148e43ed30d4e44d617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll the result of the query.  <a href="#a361988764d293148e43ed30d4e44d617">More...</a><br /></td></tr>
<tr class="separator:a361988764d293148e43ed30d4e44d617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2f471085d6d8a57d269f48f56f91ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1query.html#ada2f471085d6d8a57d269f48f56f91ee">poll_result</a> (GLuint &amp;result)</td></tr>
<tr class="memdesc:ada2f471085d6d8a57d269f48f56f91ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll the result of the query.  <a href="#ada2f471085d6d8a57d269f48f56f91ee">More...</a><br /></td></tr>
<tr class="separator:ada2f471085d6d8a57d269f48f56f91ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;GLenum Target&gt;<br />
class gls::query&lt; Target &gt;</h3>

<p>Class encapsulating an OpenGL query object. </p>
<p>A <a class="el" href="classgls_1_1query.html" title="Class encapsulating an OpenGL query object. ">gls::query</a> is an object that encapsulates an OpenGL query object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Target</td><td>The target established by this query when it is active</td></tr>
  </table>
  </dd>
</dl>
<p>Like all objects in GLS, the underlying name is generated at object construction and deleted at destruction. This can be retrieved with <a class="el" href="classgls_1_1query.html#a4854c785616be504e5b5a03ea3802ce0" title="Retrieve the OpenGL name of this query. ">name()</a>.</p>
<p>Query objects are used to query counters in the GL server. The counters are reset when the query begins and their value stored in the query object once the query ends. Common targets for a query are GL_SAMPLES_PASSED and GL_PRIMITIVES_GENERATED. If ARB_timer_query or OpenGL 3.3 is available, GL_TIME_ELAPSED is also common.</p>
<p>You can use a <a class="el" href="classgls_1_1query.html" title="Class encapsulating an OpenGL query object. ">gls::query</a> in 2 ways. The first method is closer to the way you would perform them yourself using OpenGL code directly, manually using <a class="el" href="classgls_1_1query.html#ab0bdf5cca484fb2ba637c39384b27fb2" title="Mark the begin of the query block. ">begin()</a> and <a class="el" href="classgls_1_1query.html#aaf81d3fdaf258088d7692fa70cece087" title="Mark the end of the query block. ">end()</a>. The second method using <a class="el" href="classgls_1_1query.html#a135fe90ca531f4a7b04d00642b9f0ef6" title="Run the query on the provided callable. ">run()</a> automatically takes care of calling <a class="el" href="classgls_1_1query.html#aaf81d3fdaf258088d7692fa70cece087" title="Mark the end of the query block. ">end()</a> for you once the callable has returned, thus it might be more convenient depending on the scenario. Either way, once <a class="el" href="classgls_1_1query.html#aaf81d3fdaf258088d7692fa70cece087" title="Mark the end of the query block. ">end()</a> has been called, either manually or automatically, you will need to periodically poll for the result. Once it is ready, you can start another query using this object.</p>
<p>Note that running 2 simultaneous queries with the same target will produce an OpenGL error. This will not happen if using <a class="el" href="classgls_1_1query.html#a135fe90ca531f4a7b04d00642b9f0ef6" title="Run the query on the provided callable. ">run()</a>.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> query = <a class="code" href="classgls_1_1query.html">gls::query&lt;GL_SAMPLES_PASSED&gt;</a>();</div>
<div class="line">query.<a class="code" href="classgls_1_1query.html#a135fe90ca531f4a7b04d00642b9f0ef6">run</a>( [&amp;]() {</div>
<div class="line"></div>
<div class="line">    ... some OpenGL code producing samples here ...</div>
<div class="line"></div>
<div class="line">} );</div>
<div class="line"></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">auto result = GLuint( 0 );</div>
<div class="line"><span class="keywordflow">if</span>( query.poll_result( result ) ) {</div>
<div class="line">    ... <span class="keywordflow">do</span> something with the result ...</div>
<div class="line">}</div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4854c785616be504e5b5a03ea3802ce0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the OpenGL name of this query. </p>
<dl class="section return"><dt>Returns</dt><dd>OpenGL name of this query </dd></dl>

</div>
</div>
<a class="anchor" id="a135fe90ca531f4a7b04d00642b9f0ef6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void run </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the query on the provided callable. </p>
<p>The callable should take no parameters, and its return value is ignored by <a class="el" href="classgls_1_1query.html#a135fe90ca531f4a7b04d00642b9f0ef6" title="Run the query on the provided callable. ">run()</a>.</p>
<p>If a previous query is not pending <a class="el" href="classgls_1_1query.html#ab0bdf5cca484fb2ba637c39384b27fb2" title="Mark the begin of the query block. ">begin()</a> will be called, followed by the callable and then <a class="el" href="classgls_1_1query.html#aaf81d3fdaf258088d7692fa70cece087" title="Mark the end of the query block. ">end()</a>. Prefer using this method over <a class="el" href="classgls_1_1query.html#ab0bdf5cca484fb2ba637c39384b27fb2" title="Mark the begin of the query block. ">begin()</a> and <a class="el" href="classgls_1_1query.html#aaf81d3fdaf258088d7692fa70cece087" title="Mark the end of the query block. ">end()</a> when possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>Callable to run between <a class="el" href="classgls_1_1query.html#ab0bdf5cca484fb2ba637c39384b27fb2" title="Mark the begin of the query block. ">begin()</a> and <a class="el" href="classgls_1_1query.html#aaf81d3fdaf258088d7692fa70cece087" title="Mark the end of the query block. ">end()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0bdf5cca484fb2ba637c39384b27fb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the begin of the query block. </p>
<p>If a previous query is still pending, calling this method will have no affect. </p>

</div>
</div>
<a class="anchor" id="aaf81d3fdaf258088d7692fa70cece087"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the end of the query block. </p>
<p>Calling this method if this query is not currently active will produce an OpenGL error. </p>

</div>
</div>
<a class="anchor" id="a361988764d293148e43ed30d4e44d617"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool poll_result </td>
          <td>(</td>
          <td class="paramtype">GLint &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll the result of the query. </p>
<p>After running <a class="el" href="classgls_1_1query.html#a135fe90ca531f4a7b04d00642b9f0ef6" title="Run the query on the provided callable. ">run()</a> or ending a block with <a class="el" href="classgls_1_1query.html#aaf81d3fdaf258088d7692fa70cece087" title="Mark the end of the query block. ">end()</a>, you can periodically poll the result of the query using this method. It will return true to signal the result passed in the result parameter is valid for use and false otherwise if the query is not yet ready.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>Variable to store the query result in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the result is ready and valid, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ada2f471085d6d8a57d269f48f56f91ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool poll_result </td>
          <td>(</td>
          <td class="paramtype">GLuint &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll the result of the query. </p>
<p>After running <a class="el" href="classgls_1_1query.html#a135fe90ca531f4a7b04d00642b9f0ef6" title="Run the query on the provided callable. ">run()</a> or ending a block with <a class="el" href="classgls_1_1query.html#aaf81d3fdaf258088d7692fa70cece087" title="Mark the end of the query block. ">end()</a>, you can periodically poll the result of the query using this method. It will return true to signal the result passed in the result parameter is valid for use and false otherwise if the query is not yet ready.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>Variable to store the query result in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the result is ready and valid, false otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
