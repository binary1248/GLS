<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>GLS: framebuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GLS
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">GL Stuff - A library aimed at reducing the boilerplate OpenGL code you always have to write.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classgls_1_1framebuffer.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classgls_1_1framebuffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">framebuffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class encapsulating an OpenGL framebuffer object.  
 <a href="classgls_1_1framebuffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="framebuffer_8hpp_source.html">framebuffer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4854c785616be504e5b5a03ea3802ce0"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1framebuffer.html#a4854c785616be504e5b5a03ea3802ce0">name</a> () const </td></tr>
<tr class="memdesc:a4854c785616be504e5b5a03ea3802ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the OpenGL name of this framebuffer.  <a href="#a4854c785616be504e5b5a03ea3802ce0">More...</a><br /></td></tr>
<tr class="separator:a4854c785616be504e5b5a03ea3802ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d1656e5add9a86bc733cc3c21ae81e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1framebuffer.html#a51d1656e5add9a86bc733cc3c21ae81e">bind</a> ()</td></tr>
<tr class="memdesc:a51d1656e5add9a86bc733cc3c21ae81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind this framebuffer to the GL_FRAMEBUFFER target.  <a href="#a51d1656e5add9a86bc733cc3c21ae81e">More...</a><br /></td></tr>
<tr class="separator:a51d1656e5add9a86bc733cc3c21ae81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a27f1a7ff7ce2a1a2ac278cc2b63d0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1framebuffer.html#a1a27f1a7ff7ce2a1a2ac278cc2b63d0f">attach_texture</a> (GLenum attachment, GLenum textarget, const <a class="el" href="classgls_1_1texture.html">texture</a>&lt; GL_TEXTURE_CUBE_MAP &gt; &amp;the_texture, GLint level)</td></tr>
<tr class="memdesc:a1a27f1a7ff7ce2a1a2ac278cc2b63d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a non-array cubemap to the given attachment.  <a href="#a1a27f1a7ff7ce2a1a2ac278cc2b63d0f">More...</a><br /></td></tr>
<tr class="separator:a1a27f1a7ff7ce2a1a2ac278cc2b63d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0e63af10b5a8d8d22c5c445909e60c"><td class="memTemplParams" colspan="2">template&lt;GLenum Target&gt; </td></tr>
<tr class="memitem:a2c0e63af10b5a8d8d22c5c445909e60c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgls_1_1framebuffer.html#a2c0e63af10b5a8d8d22c5c445909e60c">attach_texture</a> (GLenum attachment, const <a class="el" href="classgls_1_1texture.html">texture</a>&lt; Target &gt; &amp;the_texture, GLint level)</td></tr>
<tr class="memdesc:a2c0e63af10b5a8d8d22c5c445909e60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a texture to the given attachment.  <a href="#a2c0e63af10b5a8d8d22c5c445909e60c">More...</a><br /></td></tr>
<tr class="separator:a2c0e63af10b5a8d8d22c5c445909e60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faa2073d54f2345e38aefe200dddae7"><td class="memTemplParams" colspan="2">template&lt;GLenum Target&gt; </td></tr>
<tr class="memitem:a1faa2073d54f2345e38aefe200dddae7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgls_1_1framebuffer.html#a1faa2073d54f2345e38aefe200dddae7">attach_texture_layer</a> (GLenum attachment, const <a class="el" href="classgls_1_1texture.html">texture</a>&lt; Target &gt; &amp;the_texture, GLint level, GLint layer)</td></tr>
<tr class="memdesc:a1faa2073d54f2345e38aefe200dddae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a texture layer to the given attachment.  <a href="#a1faa2073d54f2345e38aefe200dddae7">More...</a><br /></td></tr>
<tr class="separator:a1faa2073d54f2345e38aefe200dddae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107994f3bd6c4f5af6bdc983ead346bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1framebuffer.html#a107994f3bd6c4f5af6bdc983ead346bc">detach_texture</a> (GLenum attachment)</td></tr>
<tr class="memdesc:a107994f3bd6c4f5af6bdc983ead346bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a texture attachment.  <a href="#a107994f3bd6c4f5af6bdc983ead346bc">More...</a><br /></td></tr>
<tr class="separator:a107994f3bd6c4f5af6bdc983ead346bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e469247fceb63da45593d17eed14fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1framebuffer.html#a07e469247fceb63da45593d17eed14fe">add_renderbuffer</a> (GLenum attachment, <a class="el" href="classgls_1_1renderbuffer.html">renderbuffer</a> &amp;&amp;the_renderbuffer)</td></tr>
<tr class="memdesc:a07e469247fceb63da45593d17eed14fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a renderbuffer to the given attachment.  <a href="#a07e469247fceb63da45593d17eed14fe">More...</a><br /></td></tr>
<tr class="separator:a07e469247fceb63da45593d17eed14fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e0fd9ef895fe183207f58ec5322b34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1framebuffer.html#a56e0fd9ef895fe183207f58ec5322b34">remove_renderbuffer</a> (GLenum attachment)</td></tr>
<tr class="memdesc:a56e0fd9ef895fe183207f58ec5322b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a renderbuffer attachment.  <a href="#a56e0fd9ef895fe183207f58ec5322b34">More...</a><br /></td></tr>
<tr class="separator:a56e0fd9ef895fe183207f58ec5322b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23f201a6c13fb7cdc25adf11f9e8a5d"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1framebuffer.html#ad23f201a6c13fb7cdc25adf11f9e8a5d">status</a> ()</td></tr>
<tr class="memdesc:ad23f201a6c13fb7cdc25adf11f9e8a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the status of the framebuffer.  <a href="#ad23f201a6c13fb7cdc25adf11f9e8a5d">More...</a><br /></td></tr>
<tr class="separator:ad23f201a6c13fb7cdc25adf11f9e8a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052a3064081f9c45c97b467fba70b73b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1framebuffer.html#a052a3064081f9c45c97b467fba70b73b">complete</a> ()</td></tr>
<tr class="memdesc:a052a3064081f9c45c97b467fba70b73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the framebuffer is complete.  <a href="#a052a3064081f9c45c97b467fba70b73b">More...</a><br /></td></tr>
<tr class="separator:a052a3064081f9c45c97b467fba70b73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afec97de60a74d4ae7e752924902c4320"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgls_1_1framebuffer.html#afec97de60a74d4ae7e752924902c4320">unbind</a> ()</td></tr>
<tr class="memdesc:afec97de60a74d4ae7e752924902c4320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind the framebuffer currently bound to the GL_FRAMEBUFFER target.  <a href="#afec97de60a74d4ae7e752924902c4320">More...</a><br /></td></tr>
<tr class="separator:afec97de60a74d4ae7e752924902c4320"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class encapsulating an OpenGL framebuffer object. </p>
<p>A <a class="el" href="classgls_1_1framebuffer.html" title="Class encapsulating an OpenGL framebuffer object. ">gls::framebuffer</a> is an object that encapsulates an OpenGL framebuffer object.</p>
<p>Like all objects in GLS, the underlying name is generated at object construction and deleted at destruction. This can be retrieved with <a class="el" href="classgls_1_1framebuffer.html#a4854c785616be504e5b5a03ea3802ce0" title="Retrieve the OpenGL name of this framebuffer. ">name()</a>.</p>
<p><b>WARNING:</b> Unlike other OpenGL objects, framebuffer objects are <em>not</em> shareable between contexts. As such, a <a class="el" href="classgls_1_1framebuffer.html" title="Class encapsulating an OpenGL framebuffer object. ">gls::framebuffer</a> object is only valid for use within the context where it was constructed. No checks are made to ensure it is used properly. If strange behaviour occurs, be sure to check the reported OpenGL errors in a debug configuration and assure you are not transferring the <a class="el" href="classgls_1_1framebuffer.html" title="Class encapsulating an OpenGL framebuffer object. ">gls::framebuffer</a> between contexts.</p>
<p>Framebuffer objects are the primary way of rendering to an offscreen surface on hardware that supports it. By default, i.e. when 0 is bound to GL_FRAMEBUFFER all draw commands affect the default framebuffer, typically the back buffer in double buffered applications. To draw to a framebuffer object instead, it has to be bound. All draw commands that are issued while it is bound will affect the framebuffer and its attachments. Once you want to draw to the back buffer once again, simply unbind the framebuffer.</p>
<p>The framebuffer attachments represent surfaces on which draw commands will have an affect. The depth attachment will have depth values written to it while the colour attachments will have colour values written to it and so on. The storage for these attachments comes either from standard texture objects or, since texture objects cannot store non-colour values, renderbuffer objects. The <a class="el" href="classgls_1_1framebuffer.html" title="Class encapsulating an OpenGL framebuffer object. ">gls::framebuffer</a> object will take ownership of any <a class="el" href="classgls_1_1renderbuffer.html" title="Class encapsulating an OpenGL renderbuffer object. ">gls::renderbuffer</a> objects that are attached to it. After all draw commands affecting the framebuffer have completed, one can use the attached texture objects much like one would use any other texture object. Just beware of <a href="https://www.opengl.org/wiki/Memory_Model#Framebuffer_objects">feedback loops</a>.</p>
<p>After assembling a framebuffer from its attachments and before rendering to it, it is always a good idea to check whether it is complete. This can be done simply by calling <a class="el" href="classgls_1_1framebuffer.html#a052a3064081f9c45c97b467fba70b73b" title="Check if the framebuffer is complete. ">complete()</a>. If it is incomplete, calling <a class="el" href="classgls_1_1framebuffer.html#ad23f201a6c13fb7cdc25adf11f9e8a5d" title="Check the status of the framebuffer. ">status()</a> will return the reason for its incompleteness.</p>
<p>To render to a <a class="el" href="classgls_1_1framebuffer.html" title="Class encapsulating an OpenGL framebuffer object. ">gls::framebuffer</a>, simply call <a class="el" href="classgls_1_1framebuffer.html#a51d1656e5add9a86bc733cc3c21ae81e" title="Bind this framebuffer to the GL_FRAMEBUFFER target. ">bind()</a>. It will bind the <a class="el" href="classgls_1_1framebuffer.html" title="Class encapsulating an OpenGL framebuffer object. ">gls::framebuffer</a> to the GL_FRAMEBUFFER binding and replace any previously bound to that target. To clear the GL_FRAMEBUFFER binding and render to the back buffer again, call <a class="el" href="classgls_1_1framebuffer.html#afec97de60a74d4ae7e752924902c4320" title="Unbind the framebuffer currently bound to the GL_FRAMEBUFFER target. ">unbind()</a>.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> texture = <a class="code" href="classgls_1_1texture.html">gls::texture&lt;GL_TEXTURE_2D&gt;</a>();</div>
<div class="line">texture.<a class="code" href="classgls_1_1texture.html#ab92f4568d07eefdbbb55effc45d2705d">image_2d</a>( 0, GL_RGBA, 100, 100, GL_RGBA, GL_FLOAT, <span class="keyword">nullptr</span> );</div>
<div class="line"><span class="keyword">auto</span> framebuffer = <a class="code" href="classgls_1_1framebuffer.html">gls::framebuffer</a>();</div>
<div class="line">framebuffer.attach_texture( GL_COLOR_ATTACHMENT0, texture, 0 );</div>
<div class="line">framebuffer.add_renderbuffer( GL_DEPTH_ATTACHMENT, <a class="code" href="classgls_1_1renderbuffer.html">gls::renderbuffer</a>( GL_DEPTH_COMPONENT24, 100, 100 ) );</div>
<div class="line"><span class="keywordflow">if</span>( !framebuffer.complete() ) {</div>
<div class="line">    ... framebuffer is not <a class="code" href="classgls_1_1framebuffer.html#a052a3064081f9c45c97b467fba70b73b">complete</a> ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">framebuffer.bind();</div>
<div class="line"></div>
<div class="line">... draw stuff to the framebuffer ...</div>
<div class="line"></div>
<div class="line">framebuffer.unbind();</div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4854c785616be504e5b5a03ea3802ce0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the OpenGL name of this framebuffer. </p>
<dl class="section return"><dt>Returns</dt><dd>OpenGL name of this framebuffer </dd></dl>

</div>
</div>
<a class="anchor" id="a51d1656e5add9a86bc733cc3c21ae81e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind this framebuffer to the GL_FRAMEBUFFER target. </p>
<p>If you want to bind this framebuffer to a target other than GL_FRAMEBUFFER, you can always do this manually with: </p><div class="fragment"><div class="line">glBindFramebuffer( &lt;your target&gt;, framebuffer.name() );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="afec97de60a74d4ae7e752924902c4320"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void unbind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unbind the framebuffer currently bound to the GL_FRAMEBUFFER target. </p>
<p>If you want to unbind a framebuffer that is bound to a target other than GL_FRAMEBUFFER, you can always do this manually with: </p><div class="fragment"><div class="line">glBindFramebuffer( &lt;your target&gt;, 0 );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a1a27f1a7ff7ce2a1a2ac278cc2b63d0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void attach_texture </td>
          <td>(</td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>attachment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>textarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgls_1_1texture.html">texture</a>&lt; GL_TEXTURE_CUBE_MAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>the_texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a non-array cubemap to the given attachment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachment</td><td>Attachment to attach to </td></tr>
    <tr><td class="paramname">textarget</td><td>Cubemap texture target (GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, etc.) </td></tr>
    <tr><td class="paramname">the_texture</td><td>The cubemap texture to attach </td></tr>
    <tr><td class="paramname">level</td><td>Level of the cubemap texture to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c0e63af10b5a8d8d22c5c445909e60c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void attach_texture </td>
          <td>(</td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>attachment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgls_1_1texture.html">texture</a>&lt; Target &gt; &amp;&#160;</td>
          <td class="paramname"><em>the_texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a texture to the given attachment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachment</td><td>Attachment to attach to </td></tr>
    <tr><td class="paramname">the_texture</td><td>The texture to attach </td></tr>
    <tr><td class="paramname">level</td><td>Level of the texture to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1faa2073d54f2345e38aefe200dddae7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void attach_texture_layer </td>
          <td>(</td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>attachment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgls_1_1texture.html">texture</a>&lt; Target &gt; &amp;&#160;</td>
          <td class="paramname"><em>the_texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a texture layer to the given attachment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachment</td><td>Attachment to attach to </td></tr>
    <tr><td class="paramname">the_texture</td><td>The texture to attach </td></tr>
    <tr><td class="paramname">level</td><td>Level of the texture to attach </td></tr>
    <tr><td class="paramname">layer</td><td>Layer of the texture to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a107994f3bd6c4f5af6bdc983ead346bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void detach_texture </td>
          <td>(</td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>attachment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a texture attachment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachment</td><td>Attachment to detach a texture from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07e469247fceb63da45593d17eed14fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_renderbuffer </td>
          <td>(</td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>attachment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgls_1_1renderbuffer.html">renderbuffer</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>the_renderbuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a renderbuffer to the given attachment. </p>
<p>Note: This method requires that you transfer ownership (i.e. std::move or equivalent) of the renderbuffer to the framebuffer. It will be destroyed either when the attachment is cleared or the <a class="el" href="classgls_1_1framebuffer.html" title="Class encapsulating an OpenGL framebuffer object. ">gls::framebuffer</a> is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachment</td><td>Attachment to attach to </td></tr>
    <tr><td class="paramname">the_renderbuffer</td><td>The renderbuffer to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56e0fd9ef895fe183207f58ec5322b34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_renderbuffer </td>
          <td>(</td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>attachment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a renderbuffer attachment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachment</td><td>Attachment to detach a renderbuffer from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad23f201a6c13fb7cdc25adf11f9e8a5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the status of the framebuffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Status of the framebuffer </dd></dl>

</div>
</div>
<a class="anchor" id="a052a3064081f9c45c97b467fba70b73b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool complete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the framebuffer is complete. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the framebuffer is complete, false otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
